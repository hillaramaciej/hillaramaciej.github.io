{"version":3,"sources":["webpack:///./node_modules/flot/jquery.flot.resize.js","webpack:///./node_modules/core-js/modules/es6.array.find.js","webpack:///./node_modules/flot/jquery.flot.js"],"names":["jQuery","__webpack_require__","$","e","t","a","i","n","resize","extend","r","s","u","m","o","l","f","h","length","is","width","c","height","d","data","w","trigger","requestAnimationFrame","setTimeout","event","special","setup","this","push","teardown","splice","removeData","cancelAnimationFrame","clearTimeout","add","apply","arguments","isFunction","handler","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","Date","getTime","webkitCancelRequestAnimationFrame","mozCancelRequestAnimationFrame","oCancelRequestAnimationFrame","msCancelRequestAnimationFrame","options","init","plot","onResize","placeholder","getPlaceholder","setupGrid","draw","bindEvents","eventHolder","shutdown","unbind","hooks","plugins","name","version","call","window","$export","$find","KEY","forced","Array","P","F","find","callbackfn","undefined","color","make","g","b","charAt","normalize","scale","toString","join","clamp","min","value","max","parseInt","clone","extract","elem","css","toLowerCase","parent","nodeName","get","parse","str","res","exec","parseFloat","trim","lookupColors","aqua","azure","beige","black","blue","brown","cyan","darkblue","darkcyan","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkviolet","fuchsia","gold","green","indigo","khaki","lightblue","lightcyan","lightgreen","lightgrey","lightpink","lightyellow","lime","magenta","maroon","navy","olive","orange","pink","purple","violet","red","silver","white","yellow","hasOwnProperty","Object","prototype","Canvas","cls","container","element","children","document","createElement","className","direction","position","left","top","appendTo","getContext","G_vmlCanvasManager","Error","initElement","context","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","pixelRatio","textContainer","text","_textCache","Plot","data_","options_","series","colors","legend","show","noColumns","labelFormatter","labelBoxBorderColor","margin","backgroundColor","backgroundOpacity","sorted","xaxis","mode","font","tickColor","transform","inverseTransform","autoscaleMargin","ticks","tickFormatter","labelWidth","labelHeight","reserveSpace","tickLength","alignTicksWithAxis","tickDecimals","tickSize","minTickSize","yaxis","xaxes","yaxes","points","radius","lineWidth","fill","fillColor","symbol","lines","steps","bars","barWidth","align","horizontal","zero","shadowSize","highlightColor","grid","aboveData","borderColor","labelMargin","axisMargin","borderWidth","minBorderMargin","markings","markingsColor","markingsLineWidth","clickable","hoverable","autoHighlight","mouseActiveRadius","interaction","redrawOverlayInterval","surface","overlay","ctx","octx","plotOffset","right","bottom","plotWidth","plotHeight","processOptions","processRawData","processDatapoints","processOffset","drawBackground","drawSeries","drawOverlay","executeHooks","hook","args","concat","initPlugins","classes","p","parseOptions","opts","axisOptions","axisCount","fontSize","fontSizeDefault","replace","fontDefaults","style","size","Math","round","variant","weight","family","lineHeight","noTicks","x2axis","y2axis","coloredAreas","coloredAreasColor","getOrCreateAxis","setData","parseData","fillInSeriesOptions","processData","axisNumber","obj","coord","allAxes","grep","canvasToAxisCoords","pos","axis","used","c2p","x1","x","y1","y","axisToCanvasCoords","key","p2c","axes","number","neededColors","maxIndex","sc","colorPool","colorPoolSize","variation","colori","v","j","k","ps","val","format","topSentry","Number","POSITIVE_INFINITY","bottomSentry","NEGATIVE_INFINITY","fakeInfinity","MAX_VALUE","updateAxis","datamin","datamax","each","_","datapoints","required","autoscale","defaultValue","pointsize","insertSteps","nullify","isNaN","Infinity","xmin","ymin","xmax","ymax","delta","setupCanvases","filter","hasClass","remove","existing","clear","mousemove","onMouseMove","bind","onMouseLeave","click","onClick","redrawTimeout","setTransformationHelpers","identity","it","abs","measureTickLabels","maxWidth","floor","legacyStyles","layer","label","info","getTextInfo","allocateAxisBoxFirstPhase","lw","lh","isXAxis","padding","innermost","outermost","first","found","box","allocateAxisBoxSecondPhase","adjustLayoutForThingsStickingOut","minMargin","margins","ceil","showGrid","axisOpts","setRange","allocatedAxes","setupTickGeneration","setTicks","snapRangeToTicks","drawAxisLabels","insertLegend","widen","sqrt","dec","log","LN10","maxDec","magn","pow","norm","tickGenerator","prev","start","floorInBase","NaN","factor","formatted","decimal","indexOf","precision","substr","otherAxis","niceTicks","extraDec","ts","test","toFixed","oticks","drawGrid","render","triggerRedrawOverlay","extractRange","ranges","from","to","tmp","save","translate","fillStyle","getColorOrGradient","fillRect","restore","bw","bc","getAxes","xrange","yrange","xequal","yequal","subPixel","beginPath","strokeStyle","moveTo","lineTo","stroke","xoff","yoff","strokeRect","tick","halign","valign","removeText","addText","drawSeriesLines","drawSeriesBars","drawSeriesPoints","plotLine","xoffset","yoffset","axisx","axisy","prevx","prevy","x2","y2","plotLineArea","areaOpen","ypos","segmentStart","segmentEnd","x1old","x2old","lineJoin","sw","angle","PI","sin","cos","getFillStyle","plotPoints","offset","shadow","arc","closePath","drawBar","barLeft","barRight","fillStyleCallback","drawLeft","drawRight","drawTop","drawBottom","plotBars","filloptions","seriesColor","html","fragments","entries","rowStarted","lf","sort","reverse","ascending","entry","table","div","prependTo","getCanvas","getPlotOffset","getData","getXAxes","getYAxes","getOptions","highlight","unhighlight","pointOffset","point","destroy","empty","highlights","findNearbyItem","mouseX","mouseY","seriesFilter","maxDistance","smallestDistance","item","mx","my","maxx","maxy","dx","dy","dist","datapoint","slice","dataIndex","seriesIndex","triggerClickHoverEvent","eventname","canvasX","pageX","canvasY","pageY","auto","hi","drawBarHighlight","drawPointHighlight","indexOfHighlight","pointRadius","spec","defaultColor","gradient","createLinearGradient","co","brightness","opacity","addColorStop","base","fn","detach","parentNode","removeChild","clearRect","cache","layerKey","getTextLayer","layerCache","styleKey","hide","styleCache","positions","active","rendered","append","font-size","insertAfter","addClass","textStyle","max-width","outerWidth","outerHeight","text-align"],"mappings":"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","file":"js/chunk-464e6f04.9ee11cb9.js","sourcesContent":["/*** IMPORTS FROM imports-loader ***/\nvar jQuery = require(\"jquery\");\n(function() {\n\n/* Flot plugin for automatically redrawing plots as the placeholder resizes.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\nIt works by listening for changes on the placeholder div (through the jQuery\nresize event plugin) - if the size changes, it will redraw the plot.\n\nThere are no options. If you need to disable the plugin for some plots, you\ncan just fix the size of their placeholders.\n\n*/\n\n/* Inline dependency:\n * jQuery resize event - v1.1 - 3/14/2010\n * http://benalman.com/projects/jquery-resize-plugin/\n *\n * Copyright (c) 2010 \"Cowboy\" Ben Alman\n * Dual licensed under the MIT and GPL licenses.\n * http://benalman.com/about/license/\n */\n(function($,e,t){\"$:nomunge\";var i=[],n=$.resize=$.extend($.resize,{}),a,r=false,s=\"setTimeout\",u=\"resize\",m=u+\"-special-event\",o=\"pendingDelay\",l=\"activeDelay\",f=\"throttleWindow\";n[o]=200;n[l]=20;n[f]=true;$.event.special[u]={setup:function(){if(!n[f]&&this[s]){return false}var e=$(this);i.push(this);e.data(m,{w:e.width(),h:e.height()});if(i.length===1){a=t;h()}},teardown:function(){if(!n[f]&&this[s]){return false}var e=$(this);for(var t=i.length-1;t>=0;t--){if(i[t]==this){i.splice(t,1);break}}e.removeData(m);if(!i.length){if(r){cancelAnimationFrame(a)}else{clearTimeout(a)}a=null}},add:function(e){if(!n[f]&&this[s]){return false}var i;function a(e,n,a){var r=$(this),s=r.data(m)||{};s.w=n!==t?n:r.width();s.h=a!==t?a:r.height();i.apply(this,arguments)}if($.isFunction(e)){i=e;return a}else{i=e.handler;e.handler=a}}};function h(t){if(r===true){r=t||1}for(var s=i.length-1;s>=0;s--){var l=$(i[s]);if(l[0]==e||l.is(\":visible\")){var f=l.width(),c=l.height(),d=l.data(m);if(d&&(f!==d.w||c!==d.h)){l.trigger(u,[d.w=f,d.h=c]);r=t||true}}else{d=l.data(m);d.w=0;d.h=0}}if(a!==null){if(r&&(t==null||t-r<1e3)){a=e.requestAnimationFrame(h)}else{a=setTimeout(h,n[o]);r=false}}}if(!e.requestAnimationFrame){e.requestAnimationFrame=function(){return e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(t,i){return e.setTimeout(function(){t((new Date).getTime())},n[l])}}()}if(!e.cancelAnimationFrame){e.cancelAnimationFrame=function(){return e.webkitCancelRequestAnimationFrame||e.mozCancelRequestAnimationFrame||e.oCancelRequestAnimationFrame||e.msCancelRequestAnimationFrame||clearTimeout}()}})(jQuery,this);\n\n(function ($) {\n    var options = { }; // no options\n\n    function init(plot) {\n        function onResize() {\n            var placeholder = plot.getPlaceholder();\n\n            // somebody might have hidden us and we can't plot\n            // when we don't have the dimensions\n            if (placeholder.width() == 0 || placeholder.height() == 0)\n                return;\n\n            plot.resize();\n            plot.setupGrid();\n            plot.draw();\n        }\n        \n        function bindEvents(plot, eventHolder) {\n            plot.getPlaceholder().resize(onResize);\n        }\n\n        function shutdown(plot, eventHolder) {\n            plot.getPlaceholder().unbind(\"resize\", onResize);\n        }\n        \n        plot.hooks.bindEvents.push(bindEvents);\n        plot.hooks.shutdown.push(shutdown);\n    }\n    \n    $.plot.plugins.push({\n        init: init,\n        options: options,\n        name: 'resize',\n        version: '1.0'\n    });\n})(jQuery);\n\n}.call(window));","'use strict';\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = require('./_export');\nvar $find = require('./_array-methods')(5);\nvar KEY = 'find';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n","/*** IMPORTS FROM imports-loader ***/\nvar jQuery = require(\"jquery\");\n(function() {\n\n/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return\"rgb(\"+[o.r,o.g,o.b].join(\",\")+\")\"}else{return\"rgba(\"+[o.r,o.g,o.b,o.a].join(\",\")+\")\"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=\"\"&&c!=\"transparent\")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),\"body\"));if(c==\"rgba(0, 0, 0, 0)\")c=\"transparent\";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name==\"transparent\")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);\n\n// the actual Flot code\n(function($) {\n\n\t// Cache the prototype hasOwnProperty for faster access\n\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\n    // operation produces the same effect as detach, i.e. removing the element\n    // without touching its jQuery data.\n\n    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\n\n    if (!$.fn.detach) {\n        $.fn.detach = function() {\n            return this.each(function() {\n                if (this.parentNode) {\n                    this.parentNode.removeChild( this );\n                }\n            });\n        };\n    }\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The Canvas object is a wrapper around an HTML5 <canvas> tag.\n\t//\n\t// @constructor\n\t// @param {string} cls List of classes to apply to the canvas.\n\t// @param {element} container Element onto which to append the canvas.\n\t//\n\t// Requiring a container is a little iffy, but unfortunately canvas\n\t// operations don't work unless the canvas is attached to the DOM.\n\n\tfunction Canvas(cls, container) {\n\n\t\tvar element = container.children(\".\" + cls)[0];\n\n\t\tif (element == null) {\n\n\t\t\telement = document.createElement(\"canvas\");\n\t\t\telement.className = cls;\n\n\t\t\t$(element).css({ direction: \"ltr\", position: \"absolute\", left: 0, top: 0 })\n\t\t\t\t.appendTo(container);\n\n\t\t\t// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\n\n\t\t\tif (!element.getContext) {\n\t\t\t\tif (window.G_vmlCanvasManager) {\n\t\t\t\t\telement = window.G_vmlCanvasManager.initElement(element);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element = element;\n\n\t\tvar context = this.context = element.getContext(\"2d\");\n\n\t\t// Determine the screen's ratio of physical to device-independent\n\t\t// pixels.  This is the ratio between the canvas width that the browser\n\t\t// advertises and the number of pixels actually present in that space.\n\n\t\t// The iPhone 4, for example, has a device-independent width of 320px,\n\t\t// but its screen is actually 640px wide.  It therefore has a pixel\n\t\t// ratio of 2, while most normal devices have a ratio of 1.\n\n\t\tvar devicePixelRatio = window.devicePixelRatio || 1,\n\t\t\tbackingStoreRatio =\n\t\t\t\tcontext.webkitBackingStorePixelRatio ||\n\t\t\t\tcontext.mozBackingStorePixelRatio ||\n\t\t\t\tcontext.msBackingStorePixelRatio ||\n\t\t\t\tcontext.oBackingStorePixelRatio ||\n\t\t\t\tcontext.backingStorePixelRatio || 1;\n\n\t\tthis.pixelRatio = devicePixelRatio / backingStoreRatio;\n\n\t\t// Size the canvas to match the internal dimensions of its container\n\n\t\tthis.resize(container.width(), container.height());\n\n\t\t// Collection of HTML div layers for text overlaid onto the canvas\n\n\t\tthis.textContainer = null;\n\t\tthis.text = {};\n\n\t\t// Cache of text fragments and metrics, so we can avoid expensively\n\t\t// re-calculating them when the plot is re-rendered in a loop.\n\n\t\tthis._textCache = {};\n\t}\n\n\t// Resizes the canvas to the given dimensions.\n\t//\n\t// @param {number} width New width of the canvas, in pixels.\n\t// @param {number} width New height of the canvas, in pixels.\n\n\tCanvas.prototype.resize = function(width, height) {\n\n\t\tif (width <= 0 || height <= 0) {\n\t\t\tthrow new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height);\n\t\t}\n\n\t\tvar element = this.element,\n\t\t\tcontext = this.context,\n\t\t\tpixelRatio = this.pixelRatio;\n\n\t\t// Resize the canvas, increasing its density based on the display's\n\t\t// pixel ratio; basically giving it more pixels without increasing the\n\t\t// size of its element, to take advantage of the fact that retina\n\t\t// displays have that many more pixels in the same advertised space.\n\n\t\t// Resizing should reset the state (excanvas seems to be buggy though)\n\n\t\tif (this.width != width) {\n\t\t\telement.width = width * pixelRatio;\n\t\t\telement.style.width = width + \"px\";\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tif (this.height != height) {\n\t\t\telement.height = height * pixelRatio;\n\t\t\telement.style.height = height + \"px\";\n\t\t\tthis.height = height;\n\t\t}\n\n\t\t// Save the context, so we can reset in case we get replotted.  The\n\t\t// restore ensure that we're really back at the initial state, and\n\t\t// should be safe even if we haven't saved the initial state yet.\n\n\t\tcontext.restore();\n\t\tcontext.save();\n\n\t\t// Scale the coordinate space to match the display density; so even though we\n\t\t// may have twice as many pixels, we still want lines and other drawing to\n\t\t// appear at the same size; the extra pixels will just make them crisper.\n\n\t\tcontext.scale(pixelRatio, pixelRatio);\n\t};\n\n\t// Clears the entire canvas area, not including any overlaid HTML text\n\n\tCanvas.prototype.clear = function() {\n\t\tthis.context.clearRect(0, 0, this.width, this.height);\n\t};\n\n\t// Finishes rendering the canvas, including managing the text overlay.\n\n\tCanvas.prototype.render = function() {\n\n\t\tvar cache = this._textCache;\n\n\t\t// For each text layer, add elements marked as active that haven't\n\t\t// already been rendered, and remove those that are no longer active.\n\n\t\tfor (var layerKey in cache) {\n\t\t\tif (hasOwnProperty.call(cache, layerKey)) {\n\n\t\t\t\tvar layer = this.getTextLayer(layerKey),\n\t\t\t\t\tlayerCache = cache[layerKey];\n\n\t\t\t\tlayer.hide();\n\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tif (position.active) {\n\t\t\t\t\t\t\t\t\t\tif (!position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tlayer.append(position.element);\n\t\t\t\t\t\t\t\t\t\t\tposition.rendered = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpositions.splice(i--, 1);\n\t\t\t\t\t\t\t\t\t\tif (position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tposition.element.detach();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (positions.length == 0) {\n\t\t\t\t\t\t\t\t\tdelete styleCache[key];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlayer.show();\n\t\t\t}\n\t\t}\n\t};\n\n\t// Creates (if necessary) and returns the text overlay container.\n\t//\n\t// @param {string} classes String of space-separated CSS classes used to\n\t//     uniquely identify the text layer.\n\t// @return {object} The jQuery-wrapped text-layer div.\n\n\tCanvas.prototype.getTextLayer = function(classes) {\n\n\t\tvar layer = this.text[classes];\n\n\t\t// Create the text layer if it doesn't exist\n\n\t\tif (layer == null) {\n\n\t\t\t// Create the text layer container, if it doesn't exist\n\n\t\t\tif (this.textContainer == null) {\n\t\t\t\tthis.textContainer = $(\"<div class='flot-text'></div>\")\n\t\t\t\t\t.css({\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\tbottom: 0,\n\t\t\t\t\t\tright: 0,\n\t\t\t\t\t\t'font-size': \"smaller\",\n\t\t\t\t\t\tcolor: \"#545454\"\n\t\t\t\t\t})\n\t\t\t\t\t.insertAfter(this.element);\n\t\t\t}\n\n\t\t\tlayer = this.text[classes] = $(\"<div></div>\")\n\t\t\t\t.addClass(classes)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\tright: 0\n\t\t\t\t})\n\t\t\t\t.appendTo(this.textContainer);\n\t\t}\n\n\t\treturn layer;\n\t};\n\n\t// Creates (if necessary) and returns a text info object.\n\t//\n\t// The object looks like this:\n\t//\n\t// {\n\t//     width: Width of the text's wrapper div.\n\t//     height: Height of the text's wrapper div.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     positions: Array of positions at which this text is drawn.\n\t// }\n\t//\n\t// The positions array contains objects that look like this:\n\t//\n\t// {\n\t//     active: Flag indicating whether the text should be visible.\n\t//     rendered: Flag indicating whether the text is currently visible.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     x: X coordinate at which to draw the text.\n\t//     y: Y coordinate at which to draw the text.\n\t// }\n\t//\n\t// Each position after the first receives a clone of the original element.\n\t//\n\t// The idea is that that the width, height, and general 'identity' of the\n\t// text is constant no matter where it is placed; the placements are a\n\t// secondary property.\n\t//\n\t// Canvas maintains a cache of recently-used text info objects; getTextInfo\n\t// either returns the cached element or creates a new entry.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {string} text Text string to retrieve info for.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @return {object} a text info object.\n\n\tCanvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n\n\t\tvar textStyle, layerCache, styleCache, info;\n\n\t\t// Cast the value to a string, in case we were given a number or such\n\n\t\ttext = \"\" + text;\n\n\t\t// If the font is a font-spec object, generate a CSS font definition\n\n\t\tif (typeof font === \"object\") {\n\t\t\ttextStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family;\n\t\t} else {\n\t\t\ttextStyle = font;\n\t\t}\n\n\t\t// Retrieve (or create) the cache for the text's layer and styles\n\n\t\tlayerCache = this._textCache[layer];\n\n\t\tif (layerCache == null) {\n\t\t\tlayerCache = this._textCache[layer] = {};\n\t\t}\n\n\t\tstyleCache = layerCache[textStyle];\n\n\t\tif (styleCache == null) {\n\t\t\tstyleCache = layerCache[textStyle] = {};\n\t\t}\n\n\t\tinfo = styleCache[text];\n\n\t\t// If we can't find a matching element in our cache, create a new one\n\n\t\tif (info == null) {\n\n\t\t\tvar element = $(\"<div></div>\").html(text)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t'max-width': width,\n\t\t\t\t\ttop: -9999\n\t\t\t\t})\n\t\t\t\t.appendTo(this.getTextLayer(layer));\n\n\t\t\tif (typeof font === \"object\") {\n\t\t\t\telement.css({\n\t\t\t\t\tfont: textStyle,\n\t\t\t\t\tcolor: font.color\n\t\t\t\t});\n\t\t\t} else if (typeof font === \"string\") {\n\t\t\t\telement.addClass(font);\n\t\t\t}\n\n\t\t\tinfo = styleCache[text] = {\n\t\t\t\twidth: element.outerWidth(true),\n\t\t\t\theight: element.outerHeight(true),\n\t\t\t\telement: element,\n\t\t\t\tpositions: []\n\t\t\t};\n\n\t\t\telement.detach();\n\t\t}\n\n\t\treturn info;\n\t};\n\n\t// Adds a text string to the canvas text overlay.\n\t//\n\t// The text isn't drawn immediately; it is marked as rendering, which will\n\t// result in its addition to the canvas on the next render pass.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number} x X coordinate at which to draw the text.\n\t// @param {number} y Y coordinate at which to draw the text.\n\t// @param {string} text Text string to draw.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @param {string=} halign Horizontal alignment of the text; either \"left\",\n\t//     \"center\" or \"right\".\n\t// @param {string=} valign Vertical alignment of the text; either \"top\",\n\t//     \"middle\" or \"bottom\".\n\n\tCanvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\n\n\t\tvar info = this.getTextInfo(layer, text, font, angle, width),\n\t\t\tpositions = info.positions;\n\n\t\t// Tweak the div's position to match the text's alignment\n\n\t\tif (halign == \"center\") {\n\t\t\tx -= info.width / 2;\n\t\t} else if (halign == \"right\") {\n\t\t\tx -= info.width;\n\t\t}\n\n\t\tif (valign == \"middle\") {\n\t\t\ty -= info.height / 2;\n\t\t} else if (valign == \"bottom\") {\n\t\t\ty -= info.height;\n\t\t}\n\n\t\t// Determine whether this text already exists at this position.\n\t\t// If so, mark it for inclusion in the next render pass.\n\n\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\tposition.active = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the text doesn't exist at this position, create a new entry\n\n\t\t// For the very first position we'll re-use the original element,\n\t\t// while for subsequent ones we'll clone it.\n\n\t\tposition = {\n\t\t\tactive: true,\n\t\t\trendered: false,\n\t\t\telement: positions.length ? info.element.clone() : info.element,\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\n\t\tpositions.push(position);\n\n\t\t// Move the element to its final position within the container\n\n\t\tposition.element.css({\n\t\t\ttop: Math.round(y),\n\t\t\tleft: Math.round(x),\n\t\t\t'text-align': halign\t// In case the text wraps\n\t\t});\n\t};\n\n\t// Removes one or more text strings from the canvas text overlay.\n\t//\n\t// If no parameters are given, all text within the layer is removed.\n\t//\n\t// Note that the text is not immediately removed; it is simply marked as\n\t// inactive, which will result in its removal on the next render pass.\n\t// This avoids the performance penalty for 'clear and redraw' behavior,\n\t// where we potentially get rid of all text on a layer, but will likely\n\t// add back most or all of it later, as when redrawing axes, for example.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number=} x X coordinate of the text.\n\t// @param {number=} y Y coordinate of the text.\n\t// @param {string=} text Text string to remove.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which the text is rotated, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\n\tCanvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n\t\tif (text == null) {\n\t\t\tvar layerCache = this._textCache[layer];\n\t\t\tif (layerCache != null) {\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tposition.active = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar positions = this.getTextInfo(layer, text, font, angle).positions;\n\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\t\tposition.active = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The top-level container for the entire plot.\n\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n        var series = [],\n            options = {\n                // the color theme used for graphs\n                colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n                legend: {\n                    show: true,\n                    noColumns: 1, // number of colums in legend table\n                    labelFormatter: null, // fn: string -> string\n                    labelBoxBorderColor: \"#ccc\", // border color for the little label boxes\n                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n                    position: \"ne\", // position of default legend container within plot\n                    margin: 5, // distance from grid edge to default legend container within plot\n                    backgroundColor: null, // null means auto-detect\n                    backgroundOpacity: 0.85, // set to 0 to avoid background\n                    sorted: null    // default to no legend sorting\n                },\n                xaxis: {\n                    show: null, // null = auto-detect, true = always, false = never\n                    position: \"bottom\", // or \"top\"\n                    mode: null, // null or \"time\"\n                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n                    color: null, // base color, labels, ticks\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    transform: null, // null or f: number -> number to transform axis\n                    inverseTransform: null, // if transform is set, this should be the inverse function\n                    min: null, // min. value to show, null means set automatically\n                    max: null, // max. value to show, null means set automatically\n                    autoscaleMargin: null, // margin in % to add if auto-setting min/max\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                    tickFormatter: null, // fn: number -> string\n                    labelWidth: null, // size of tick labels in pixels\n                    labelHeight: null,\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\n                    tickLength: null, // size in pixels of ticks, or \"full\" for whole line\n                    alignTicksWithAxis: null, // axis number or null for no sync\n                    tickDecimals: null, // no. of decimals, null means auto\n                    tickSize: null, // number or [number, \"unit\"]\n                    minTickSize: null // number or [number, \"unit\"]\n                },\n                yaxis: {\n                    autoscaleMargin: 0.02,\n                    position: \"left\" // or \"right\"\n                },\n                xaxes: [],\n                yaxes: [],\n                series: {\n                    points: {\n                        show: false,\n                        radius: 3,\n                        lineWidth: 2, // in pixels\n                        fill: true,\n                        fillColor: \"#ffffff\",\n                        symbol: \"circle\" // or callback\n                    },\n                    lines: {\n                        // we don't put in show: false so we can see\n                        // whether lines were actively disabled\n                        lineWidth: 2, // in pixels\n                        fill: false,\n                        fillColor: null,\n                        steps: false\n                        // Omit 'zero', so we can later default its value to\n                        // match that of the 'fill' option.\n                    },\n                    bars: {\n                        show: false,\n                        lineWidth: 2, // in pixels\n                        barWidth: 1, // in units of the x axis\n                        fill: true,\n                        fillColor: null,\n                        align: \"left\", // \"left\", \"right\", or \"center\"\n                        horizontal: false,\n                        zero: true\n                    },\n                    shadowSize: 3,\n                    highlightColor: null\n                },\n                grid: {\n                    show: true,\n                    aboveData: false,\n                    color: \"#545454\", // primary color used for outline and labels\n                    backgroundColor: null, // null for transparent, else color\n                    borderColor: null, // set if different from the grid color\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    margin: 0, // distance from the canvas edge to the grid\n                    labelMargin: 5, // in pixels\n                    axisMargin: 8, // in pixels\n                    borderWidth: 2, // in pixels\n                    minBorderMargin: null, // in pixels, null means taken from points radius\n                    markings: null, // array of ranges or fn: axes -> array of ranges\n                    markingsColor: \"#f4f4f4\",\n                    markingsLineWidth: 2,\n                    // interactive stuff\n                    clickable: false,\n                    hoverable: false,\n                    autoHighlight: true, // highlight in case mouse is near\n                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item\n                },\n                interaction: {\n                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow\n                },\n                hooks: {}\n            },\n        surface = null,     // the canvas for the plot itself\n        overlay = null,     // canvas for interactive stuff on top of plot\n        eventHolder = null, // jQuery object that events should be bound to\n        ctx = null, octx = null,\n        xaxes = [], yaxes = [],\n        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},\n        plotWidth = 0, plotHeight = 0,\n        hooks = {\n            processOptions: [],\n            processRawData: [],\n            processDatapoints: [],\n            processOffset: [],\n            drawBackground: [],\n            drawSeries: [],\n            draw: [],\n            bindEvents: [],\n            drawOverlay: [],\n            shutdown: []\n        },\n        plot = this;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function() { return placeholder; };\n        plot.getCanvas = function() { return surface.element; };\n        plot.getPlotOffset = function() { return plotOffset; };\n        plot.width = function () { return plotWidth; };\n        plot.height = function () { return plotHeight; };\n        plot.offset = function () {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function () { return series; };\n        plot.getAxes = function () {\n            var res = {}, i;\n            $.each(xaxes.concat(yaxes), function (_, axis) {\n                if (axis)\n                    res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\n            });\n            return res;\n        };\n        plot.getXAxes = function () { return xaxes; };\n        plot.getYAxes = function () { return yaxes; };\n        plot.c2p = canvasToAxisCoords;\n        plot.p2c = axisToCanvasCoords;\n        plot.getOptions = function () { return options; };\n        plot.highlight = highlight;\n        plot.unhighlight = unhighlight;\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function(point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.destroy = function () {\n            shutdown();\n            placeholder.removeData(\"plot\").empty();\n\n            series = [];\n            options = null;\n            surface = null;\n            overlay = null;\n            eventHolder = null;\n            ctx = null;\n            octx = null;\n            xaxes = [];\n            yaxes = [];\n            hooks = null;\n            highlights = [];\n            plot = null;\n        };\n        plot.resize = function () {\n        \tvar width = placeholder.width(),\n        \t\theight = placeholder.height();\n            surface.resize(width, height);\n            overlay.resize(width, height);\n        };\n\n        // public attributes\n        plot.hooks = hooks;\n\n        // initialize\n        initPlugins(plot);\n        parseOptions(options_);\n        setupCanvases();\n        setData(data_);\n        setupGrid();\n        draw();\n        bindEvents();\n\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i)\n                hook[i].apply(this, args);\n        }\n\n        function initPlugins() {\n\n            // References to key classes, allowing plugins to modify them\n\n            var classes = {\n                Canvas: Canvas\n            };\n\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot, classes);\n                if (p.options)\n                    $.extend(true, options, p.options);\n            }\n        }\n\n        function parseOptions(opts) {\n\n            $.extend(true, options, opts);\n\n            // $.extend merges arrays, rather than replacing them.  When less\n            // colors are provided than the size of the default palette, we\n            // end up with those colors plus the remaining defaults, which is\n            // not expected behavior; avoid it by replacing them here.\n\n            if (opts && opts.colors) {\n            \toptions.colors = opts.colors;\n            }\n\n            if (options.xaxis.color == null)\n                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            if (options.yaxis.color == null)\n                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n\n            if (options.grid.borderColor == null)\n                options.grid.borderColor = options.grid.color;\n            if (options.grid.tickColor == null)\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            // Fill in defaults for axis options, including any unspecified\n            // font-spec fields, if a font-spec was provided.\n\n            // If no x/y axis options were provided, create one of each anyway,\n            // since the rest of the code assumes that they exist.\n\n            var i, axisOptions, axisCount,\n                fontSize = placeholder.css(\"font-size\"),\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n                fontDefaults = {\n                    style: placeholder.css(\"font-style\"),\n                    size: Math.round(0.8 * fontSizeDefault),\n                    variant: placeholder.css(\"font-variant\"),\n                    weight: placeholder.css(\"font-weight\"),\n                    family: placeholder.css(\"font-family\")\n                };\n\n            axisCount = options.xaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.xaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n                options.xaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            axisCount = options.yaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.yaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n                options.yaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            // backwards compatibility, to be removed in future\n            if (options.xaxis.noTicks && options.xaxis.ticks == null)\n                options.xaxis.ticks = options.xaxis.noTicks;\n            if (options.yaxis.noTicks && options.yaxis.ticks == null)\n                options.yaxis.ticks = options.yaxis.noTicks;\n            if (options.x2axis) {\n                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n                options.xaxes[1].position = \"top\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.x2axis.min == null) {\n                    options.xaxes[1].min = null;\n                }\n                if (options.x2axis.max == null) {\n                    options.xaxes[1].max = null;\n                }\n            }\n            if (options.y2axis) {\n                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n                options.yaxes[1].position = \"right\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.y2axis.min == null) {\n                    options.yaxes[1].min = null;\n                }\n                if (options.y2axis.max == null) {\n                    options.yaxes[1].max = null;\n                }\n            }\n            if (options.grid.coloredAreas)\n                options.grid.markings = options.grid.coloredAreas;\n            if (options.grid.coloredAreasColor)\n                options.grid.markingsColor = options.grid.coloredAreasColor;\n            if (options.lines)\n                $.extend(true, options.series.lines, options.lines);\n            if (options.points)\n                $.extend(true, options.series.points, options.points);\n            if (options.bars)\n                $.extend(true, options.series.bars, options.bars);\n            if (options.shadowSize != null)\n                options.series.shadowSize = options.shadowSize;\n            if (options.highlightColor != null)\n                options.series.highlightColor = options.highlightColor;\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i)\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            for (i = 0; i < options.yaxes.length; ++i)\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n\n            // add hooks from options\n            for (var n in hooks)\n                if (options.hooks[n] && options.hooks[n].length)\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\n\n            executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData();\n        }\n\n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                }\n                else\n                    s.data = d[i];\n                res.push(s);\n            }\n\n            return res;\n        }\n\n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if (typeof a == \"object\") // if we got a real axis, extract number\n                a = a.n;\n            if (typeof a != \"number\")\n                a = 1; // default to first axis\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return $.grep(xaxes.concat(yaxes), function (a) { return a; });\n        }\n\n        function canvasToAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes\n            var res = {}, i, axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used)\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used)\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\n            }\n\n            if (res.x1 !== undefined)\n                res.x = res.x1;\n            if (res.y1 !== undefined)\n                res.y = res.y1;\n\n            return res;\n        }\n\n        function axisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {}, i, axis, key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"x\";\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"y\";\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1])\n                axes[number - 1] = {\n                    n: number, // save the number for future reference\n                    direction: axes == xaxes ? \"x\" : \"y\",\n                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n                };\n\n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n\n            var neededColors = series.length, maxIndex = -1, i;\n\n            // Subtract the number of series that already have fixed colors or\n            // color indexes from the number that we still need to generate.\n\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    neededColors--;\n                    if (typeof sc == \"number\" && sc > maxIndex) {\n                        maxIndex = sc;\n                    }\n                }\n            }\n\n            // If any of the series have fixed color indexes, then we need to\n            // generate at least as many colors as the highest index.\n\n            if (neededColors <= maxIndex) {\n                neededColors = maxIndex + 1;\n            }\n\n            // Generate all the colors, using first the option colors and then\n            // variations on those colors once they're exhausted.\n\n            var c, colors = [], colorPool = options.colors,\n                colorPoolSize = colorPool.length, variation = 0;\n\n            for (i = 0; i < neededColors; i++) {\n\n                c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\n\n                // Each time we exhaust the colors in the pool we adjust\n                // a scaling factor used to produce more variations on\n                // those colors. The factor alternates negative/positive\n                // to produce lighter/darker colors.\n\n                // Reset the variation after every few cycles, or else\n                // it will end up producing only white or black colors.\n\n                if (i % colorPoolSize == 0 && i) {\n                    if (variation >= 0) {\n                        if (variation < 0.5) {\n                            variation = -variation - 0.2;\n                        } else variation = 0;\n                    } else variation = -variation;\n                }\n\n                colors[i] = c.scale('rgb', 1 + variation);\n            }\n\n            // Finalize the series options, filling in their colors\n\n            var colori = 0, s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                }\n                else if (typeof s.color == \"number\")\n                    s.color = colors[s.color].toString();\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v, show = true;\n                    for (v in s)\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    if (show)\n                        s.lines.show = true;\n                }\n\n                // If nothing was provided for lines.zero, default it to match\n                // lines.fill, since areas by default should extend to zero.\n\n                if (s.lines.zero == null) {\n                    s.lines.zero = !!s.lines.fill;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n\n        function processData() {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                fakeInfinity = Number.MAX_VALUE,\n                i, j, k, m, length,\n                s, points, ps, x, y, axis, val, f, p,\n                data, format;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min != -fakeInfinity)\n                    axis.datamin = min;\n                if (max > axis.datamax && max != fakeInfinity)\n                    axis.datamax = max;\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                // init axis\n                axis.datamin = topSentry;\n                axis.datamax = bottomSentry;\n                axis.used = false;\n            });\n\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = { points: [] };\n\n                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);\n            }\n\n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                data = s.data;\n                format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({ x: true, number: true, required: true });\n                    format.push({ y: true, number: true, required: true });\n\n                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\n                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\n                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\n                        if (s.bars.horizontal) {\n                            delete format[format.length - 1].y;\n                            format[format.length - 1].x = true;\n                        }\n                    }\n\n                    s.datapoints.format = format;\n                }\n\n                if (s.datapoints.pointsize != null)\n                    continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n\n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                var insertSteps = s.lines.show && s.lines.steps;\n                s.xaxis.used = s.yaxis.used = true;\n\n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val))\n                                        val = null;\n                                    else if (val == Infinity)\n                                        val = fakeInfinity;\n                                    else if (val == -Infinity)\n                                        val = -fakeInfinity;\n                                }\n\n                                if (val == null) {\n                                    if (f.required)\n                                        nullify = true;\n\n                                    if (f.defaultValue != null)\n                                        val = f.defaultValue;\n                                }\n                            }\n\n                            points[k + m] = val;\n                        }\n                    }\n\n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.autoscale !== false) {\n                                    if (f.x) {\n                                        updateAxis(s.xaxis, val, val);\n                                    }\n                                    if (f.y) {\n                                        updateAxis(s.yaxis, val, val);\n                                    }\n                                }\n                            }\n                            points[k + m] = null;\n                        }\n                    }\n                    else {\n                        // a little bit of line specific stuff that\n                        // perhaps shouldn't be here, but lacking\n                        // better means...\n                        if (insertSteps && k > 0\n                            && points[k - ps] != null\n                            && points[k - ps] != points[k]\n                            && points[k - ps + 1] != points[k + 1]) {\n                            // copy the point to make room for a middle point\n                            for (m = 0; m < ps; ++m)\n                                points[k + ps + m] = points[k + m];\n\n                            // middle point has same y\n                            points[k + 1] = points[k - ps + 1];\n\n                            // we've added a point, better reflect that\n                            k += ps;\n                        }\n                    }\n                }\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points;\n                ps = s.datapoints.pointsize;\n                format = s.datapoints.format;\n\n                var xmin = topSentry, ymin = topSentry,\n                    xmax = bottomSentry, ymax = bottomSentry;\n\n                for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null)\n                        continue;\n\n                    for (m = 0; m < ps; ++m) {\n                        val = points[j + m];\n                        f = format[m];\n                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)\n                            continue;\n\n                        if (f.x) {\n                            if (val < xmin)\n                                xmin = val;\n                            if (val > xmax)\n                                xmax = val;\n                        }\n                        if (f.y) {\n                            if (val < ymin)\n                                ymin = val;\n                            if (val > ymax)\n                                ymax = val;\n                        }\n                    }\n                }\n\n                if (s.bars.show) {\n                    // make sure we got room for the bar on the dancing floor\n                    var delta;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            delta = 0;\n                            break;\n                        case \"right\":\n                            delta = -s.bars.barWidth;\n                            break;\n                        default:\n                            delta = -s.bars.barWidth / 2;\n                    }\n\n                    if (s.bars.horizontal) {\n                        ymin += delta;\n                        ymax += delta + s.bars.barWidth;\n                    }\n                    else {\n                        xmin += delta;\n                        xmax += delta + s.bars.barWidth;\n                    }\n                }\n\n                updateAxis(s.xaxis, xmin, xmax);\n                updateAxis(s.yaxis, ymin, ymax);\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                if (axis.datamin == topSentry)\n                    axis.datamin = null;\n                if (axis.datamax == bottomSentry)\n                    axis.datamax = null;\n            });\n        }\n\n        function setupCanvases() {\n\n            // Make sure the placeholder is clear of everything except canvases\n            // from a previous plot in this container that we'll try to re-use.\n\n            placeholder.css(\"padding\", 0) // padding messes up the positioning\n                .children().filter(function(){\n                    return !$(this).hasClass(\"flot-overlay\") && !$(this).hasClass('flot-base');\n                }).remove();\n\n            if (placeholder.css(\"position\") == 'static')\n                placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n\n            surface = new Canvas(\"flot-base\", placeholder);\n            overlay = new Canvas(\"flot-overlay\", placeholder); // overlay canvas for interactive features\n\n            ctx = surface.context;\n            octx = overlay.context;\n\n            // define which element we're listening for events on\n            eventHolder = $(overlay.element).unbind();\n\n            // If we're re-using a plot object, shut down the old one\n\n            var existing = placeholder.data(\"plot\");\n\n            if (existing) {\n                existing.shutdown();\n                overlay.clear();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            // bind events\n            if (options.grid.hoverable) {\n                eventHolder.mousemove(onMouseMove);\n\n                // Use bind, rather than .mouseleave, because we officially\n                // still support jQuery 1.2.6, which doesn't define a shortcut\n                // for mouseenter or mouseleave.  This was a bug/oversight that\n                // was fixed somewhere around 1.3.x.  We can return to using\n                // .mouseleave when we drop support for 1.2.6.\n\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\n            }\n\n            if (options.grid.clickable)\n                eventHolder.click(onClick);\n\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function shutdown() {\n            if (redrawTimeout)\n                clearTimeout(redrawTimeout);\n\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n\n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n\n            function identity(x) { return x; }\n\n            var s, m, t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n\n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction == \"x\") {\n                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                m = Math.min(t(axis.max), t(axis.min));\n            }\n            else {\n                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t == identity) // slight optimization\n                axis.p2c = function (p) { return (p - m) * s; };\n            else\n                axis.p2c = function (p) { return (t(p) - m) * s; };\n            // canvas coordinate to data point\n            if (!it)\n                axis.c2p = function (c) { return m + c / s; };\n            else\n                axis.c2p = function (c) { return it(m + c / s); };\n        }\n\n        function measureTickLabels(axis) {\n\n            var opts = axis.options,\n                ticks = axis.ticks || [],\n                labelWidth = opts.labelWidth || 0,\n                labelHeight = opts.labelHeight || 0,\n                maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                font = opts.font || \"flot-tick-label tickLabel\";\n\n            for (var i = 0; i < ticks.length; ++i) {\n\n                var t = ticks[i];\n\n                if (!t.label)\n                    continue;\n\n                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n\n                labelWidth = Math.max(labelWidth, info.width);\n                labelHeight = Math.max(labelHeight, info.height);\n            }\n\n            axis.labelWidth = opts.labelWidth || labelWidth;\n            axis.labelHeight = opts.labelHeight || labelHeight;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset; this first phase only looks at one\n            // dimension per axis, the other dimension depends on the\n            // other axes so will have to wait\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                isXAxis = axis.direction === \"x\",\n                tickLength = axis.options.tickLength,\n                axisMargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                innermost = true,\n                outermost = true,\n                first = true,\n                found = false;\n\n            // Determine the axis's position in its direction and on its side\n\n            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\n                if (a && (a.show || a.reserveSpace)) {\n                    if (a === axis) {\n                        found = true;\n                    } else if (a.options.position === pos) {\n                        if (found) {\n                            outermost = false;\n                        } else {\n                            innermost = false;\n                        }\n                    }\n                    if (!found) {\n                        first = false;\n                    }\n                }\n            });\n\n            // The outermost axis on each side has no margin\n\n            if (outermost) {\n                axisMargin = 0;\n            }\n\n            // The ticks for the first axis in each direction stretch across\n\n            if (tickLength == null) {\n                tickLength = first ? \"full\" : 5;\n            }\n\n            if (!isNaN(+tickLength))\n                padding += +tickLength;\n\n            if (isXAxis) {\n                lh += padding;\n\n                if (pos == \"bottom\") {\n                    plotOffset.bottom += lh + axisMargin;\n                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };\n                }\n                else {\n                    axis.box = { top: plotOffset.top + axisMargin, height: lh };\n                    plotOffset.top += lh + axisMargin;\n                }\n            }\n            else {\n                lw += padding;\n\n                if (pos == \"left\") {\n                    axis.box = { left: plotOffset.left + axisMargin, width: lw };\n                    plotOffset.left += lw + axisMargin;\n                }\n                else {\n                    plotOffset.right += lw + axisMargin;\n                    axis.box = { left: surface.width - plotOffset.right, width: lw };\n                }\n            }\n\n             // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.box.padding = padding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // now that all axis boxes have been placed in one\n            // dimension, we can set the remaining dimension coordinates\n            if (axis.direction == \"x\") {\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n            }\n            else {\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n            }\n        }\n\n        function adjustLayoutForThingsStickingOut() {\n            // possibly adjust plot offset to ensure everything stays\n            // inside the canvas and isn't clipped off\n\n            var minMargin = options.grid.minBorderMargin,\n                axis, i;\n\n            // check stuff from the plot (FIXME: this should just read\n            // a value from the series, otherwise it's impossible to\n            // customize)\n            if (minMargin == null) {\n                minMargin = 0;\n                for (i = 0; i < series.length; ++i)\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));\n            }\n\n            var margins = {\n                left: minMargin,\n                right: minMargin,\n                top: minMargin,\n                bottom: minMargin\n            };\n\n            // check axis labels, note we don't check the actual\n            // labels but instead use the overall width/height to not\n            // jump as much around with replots\n            $.each(allAxes(), function (_, axis) {\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n                    if (axis.direction === \"x\") {\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\n                    } else {\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\n                    }\n                }\n            });\n\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n        }\n\n        function setupGrid() {\n            var i, axes = allAxes(), showGrid = options.grid.show;\n\n            // Initialize the plot's offset from the edge of the canvas\n\n            for (var a in plotOffset) {\n                var margin = options.grid.margin || 0;\n                plotOffset[a] = typeof margin == \"number\" ? margin : margin[a] || 0;\n            }\n\n            executeHooks(hooks.processOffset, [plotOffset]);\n\n            // If the grid is visible, add its border width to the offset\n\n            for (var a in plotOffset) {\n                if(typeof(options.grid.borderWidth) == \"object\") {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n                }\n                else {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n                }\n            }\n\n            $.each(axes, function (_, axis) {\n                var axisOpts = axis.options;\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n                setRange(axis);\n            });\n\n            if (showGrid) {\n\n                var allocatedAxes = $.grep(axes, function (axis) {\n                    return axis.show || axis.reserveSpace;\n                });\n\n                $.each(allocatedAxes, function (_, axis) {\n                    // make the ticks\n                    setupTickGeneration(axis);\n                    setTicks(axis);\n                    snapRangeToTicks(axis, axis.ticks);\n                    // find labelWidth/Height for axis\n                    measureTickLabels(axis);\n                });\n\n                // with all dimensions calculated, we can compute the\n                // axis bounding boxes, start from the outside\n                // (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i)\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n\n                // make sure we've got enough space for things that\n                // might stick out\n                adjustLayoutForThingsStickingOut();\n\n                $.each(allocatedAxes, function (_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n            }\n\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plot dimensions, we can compute the scaling\n            $.each(axes, function (_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (showGrid) {\n                drawAxisLabels();\n            }\n\n            insertLegend();\n        }\n\n        function setRange(axis) {\n            var opts = axis.options,\n                min = +(opts.min != null ? opts.min : axis.datamin),\n                max = +(opts.max != null ? opts.max : axis.datamax),\n                delta = max - min;\n\n            if (delta == 0.0) {\n                // degenerate case\n                var widen = max == 0 ? 1 : 0.01;\n\n                if (opts.min == null)\n                    min -= widen;\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (opts.max == null || opts.min != null)\n                    max += widen;\n            }\n            else {\n                // consider autoscaling\n                var margin = opts.autoscaleMargin;\n                if (margin != null) {\n                    if (opts.min == null) {\n                        min -= delta * margin;\n                        // make sure we don't go below zero if all values\n                        // are positive\n                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)\n                            min = 0;\n                    }\n                    if (opts.max == null) {\n                        max += delta * margin;\n                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)\n                            max = 0;\n                    }\n                }\n            }\n            axis.min = min;\n            axis.max = max;\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n\n            // estimate number of ticks\n            var noTicks;\n            if (typeof opts.ticks == \"number\" && opts.ticks > 0)\n                noTicks = opts.ticks;\n            else\n                // heuristic based on the model a*sqrt(x) fitted to\n                // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? surface.width : surface.height);\n\n            var delta = (axis.max - axis.min) / noTicks,\n                dec = -Math.floor(Math.log(delta) / Math.LN10),\n                maxDec = opts.tickDecimals;\n\n            if (maxDec != null && dec > maxDec) {\n                dec = maxDec;\n            }\n\n            var magn = Math.pow(10, -dec),\n                norm = delta / magn, // norm is between 1.0 and 10.0\n                size;\n\n            if (norm < 1.5) {\n                size = 1;\n            } else if (norm < 3) {\n                size = 2;\n                // special case for 2.5, requires an extra decimal\n                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n                    size = 2.5;\n                    ++dec;\n                }\n            } else if (norm < 7.5) {\n                size = 5;\n            } else {\n                size = 10;\n            }\n\n            size *= magn;\n\n            if (opts.minTickSize != null && size < opts.minTickSize) {\n                size = opts.minTickSize;\n            }\n\n            axis.delta = delta;\n            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n            axis.tickSize = opts.tickSize || size;\n\n            // Time mode was moved to a plug-in in 0.8, and since so many people use it\n            // we'll add an especially friendly reminder to make sure they included it.\n\n            if (opts.mode == \"time\" && !axis.tickGenerator) {\n                throw new Error(\"Time mode requires the flot.time plugin.\");\n            }\n\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n            // like flot.time.js.\n\n            if (!axis.tickGenerator) {\n\n                axis.tickGenerator = function (axis) {\n\n                    var ticks = [],\n                        start = floorInBase(axis.min, axis.tickSize),\n                        i = 0,\n                        v = Number.NaN,\n                        prev;\n\n                    do {\n                        prev = v;\n                        v = start + i * axis.tickSize;\n                        ticks.push(v);\n                        ++i;\n                    } while (v < axis.max && v != prev);\n                    return ticks;\n                };\n\n\t\t\t\taxis.tickFormatter = function (value, axis) {\n\n\t\t\t\t\tvar factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n\t\t\t\t\tvar formatted = \"\" + Math.round(value * factor) / factor;\n\n\t\t\t\t\t// If tickDecimals was specified, ensure that we have exactly that\n\t\t\t\t\t// much precision; otherwise default to the value's own precision.\n\n\t\t\t\t\tif (axis.tickDecimals != null) {\n\t\t\t\t\t\tvar decimal = formatted.indexOf(\".\");\n\t\t\t\t\t\tvar precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n\t\t\t\t\t\tif (precision < axis.tickDecimals) {\n\t\t\t\t\t\t\treturn (precision ? formatted : formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n                    return formatted;\n                };\n            }\n\n            if ($.isFunction(opts.tickFormatter))\n                axis.tickFormatter = function (v, axis) { return \"\" + opts.tickFormatter(v, axis); };\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis != axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = axis.tickGenerator(axis);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null)\n                            axis.min = Math.min(axis.min, niceTicks[0]);\n                        if (opts.max == null && niceTicks.length > 1)\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                    }\n\n                    axis.tickGenerator = function (axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [], v, i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n\n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (!axis.mode && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                            ts = axis.tickGenerator(axis);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))\n                            axis.tickDecimals = extraDec;\n                    }\n                }\n            }\n        }\n\n        function setTicks(axis) {\n            var oticks = axis.options.ticks, ticks = [];\n            if (oticks == null || (typeof oticks == \"number\" && oticks > 0))\n                ticks = axis.tickGenerator(axis);\n            else if (oticks) {\n                if ($.isFunction(oticks))\n                    // generate the ticks\n                    ticks = oticks(axis);\n                else\n                    ticks = oticks;\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if (typeof t == \"object\") {\n                    v = +t[0];\n                    if (t.length > 1)\n                        label = t[1];\n                }\n                else\n                    v = +t;\n                if (label == null)\n                    label = axis.tickFormatter(v, axis);\n                if (!isNaN(v))\n                    axis.ticks.push({ v: v, label: label });\n            }\n        }\n\n        function snapRangeToTicks(axis, ticks) {\n            if (axis.options.autoscaleMargin && ticks.length > 0) {\n                // snap to ticks\n                if (axis.options.min == null)\n                    axis.min = Math.min(axis.min, ticks[0].v);\n                if (axis.options.max == null && ticks.length > 1)\n                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n            }\n        }\n\n        function draw() {\n\n            surface.clear();\n\n            executeHooks(hooks.drawBackground, [ctx]);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor)\n                drawBackground();\n\n            if (grid.show && !grid.aboveData) {\n                drawGrid();\n            }\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i]]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n\n            if (grid.show && grid.aboveData) {\n                drawGrid();\n            }\n\n            surface.render();\n\n            // A draw implies that either the axes or data have changed, so we\n            // should probably update the overlay highlights as well.\n\n            triggerRedrawOverlay();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = allAxes();\n\n            for (var i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction == coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n == 1)\n                        key = coord + \"axis\"; // support x1axis as xaxis\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return { from: from, to: to, axis: axis };\n        }\n\n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawGrid() {\n            var i, axes, bw, bc;\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // draw markings\n            var markings = options.grid.markings;\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n\n                    markings = markings(axes);\n                }\n\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null)\n                        xrange.from = xrange.axis.min;\n                    if (xrange.to == null)\n                        xrange.to = xrange.axis.max;\n                    if (yrange.from == null)\n                        yrange.from = yrange.axis.min;\n                    if (yrange.to == null)\n                        yrange.to = yrange.axis.max;\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)\n                        continue;\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    var xequal = xrange.from === xrange.to,\n                        yequal = yrange.from === yrange.to;\n\n                    if (xequal && yequal) {\n                        continue;\n                    }\n\n                    // then draw\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n                    if (xequal || yequal) {\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = lineWidth;\n                        if (xequal) {\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\n                        } else {\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);                            \n                        }\n                        ctx.stroke();\n                    } else {\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to,\n                                     xrange.to - xrange.from,\n                                     yrange.from - yrange.to);\n                    }\n                }\n            }\n\n            // draw the ticks\n            axes = allAxes();\n            bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j], box = axis.box,\n                    t = axis.tickLength, x, y, xoff, yoff;\n                if (!axis.show || axis.ticks.length == 0)\n                    continue;\n\n                ctx.lineWidth = 1;\n\n                // find the edges\n                if (axis.direction == \"x\") {\n                    x = 0;\n                    if (t == \"full\")\n                        y = (axis.position == \"top\" ? 0 : plotHeight);\n                    else\n                        y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\n                }\n                else {\n                    y = 0;\n                    if (t == \"full\")\n                        x = (axis.position == \"left\" ? 0 : plotWidth);\n                    else\n                        x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\n                }\n\n                // draw tick bar\n                if (!axis.innermost) {\n                    ctx.strokeStyle = axis.options.color;\n                    ctx.beginPath();\n                    xoff = yoff = 0;\n                    if (axis.direction == \"x\")\n                        xoff = plotWidth + 1;\n                    else\n                        yoff = plotHeight + 1;\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\") {\n                            y = Math.floor(y) + 0.5;\n                        } else {\n                            x = Math.floor(x) + 0.5;\n                        }\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                    ctx.stroke();\n                }\n\n                // draw ticks\n\n                ctx.strokeStyle = axis.options.tickColor;\n\n                ctx.beginPath();\n                for (i = 0; i < axis.ticks.length; ++i) {\n                    var v = axis.ticks[i].v;\n\n                    xoff = yoff = 0;\n\n                    if (isNaN(v) || v < axis.min || v > axis.max\n                        // skip those lying on the axes if we got a border\n                        || (t == \"full\"\n                            && ((typeof bw == \"object\" && bw[axis.position] > 0) || bw > 0)\n                            && (v == axis.min || v == axis.max)))\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t == \"full\" ? -plotHeight : t;\n\n                        if (axis.position == \"top\")\n                            yoff = -yoff;\n                    }\n                    else {\n                        y = axis.p2c(v);\n                        xoff = t == \"full\" ? -plotWidth : t;\n\n                        if (axis.position == \"left\")\n                            xoff = -xoff;\n                    }\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\")\n                            x = Math.floor(x) + 0.5;\n                        else\n                            y = Math.floor(y) + 0.5;\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n\n                ctx.stroke();\n            }\n\n\n            // draw border\n            if (bw) {\n                // If either borderWidth or borderColor is an object, then draw the border\n                // line by line instead of as one rectangle\n                bc = options.grid.borderColor;\n                if(typeof bw == \"object\" || typeof bc == \"object\") {\n                    if (typeof bw !== \"object\") {\n                        bw = {top: bw, right: bw, bottom: bw, left: bw};\n                    }\n                    if (typeof bc !== \"object\") {\n                        bc = {top: bc, right: bc, bottom: bc, left: bc};\n                    }\n\n                    if (bw.top > 0) {\n                        ctx.strokeStyle = bc.top;\n                        ctx.lineWidth = bw.top;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);\n                        ctx.lineTo(plotWidth, 0 - bw.top/2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.right > 0) {\n                        ctx.strokeStyle = bc.right;\n                        ctx.lineWidth = bw.right;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n                        ctx.stroke();\n                    }\n\n                    if (bw.bottom > 0) {\n                        ctx.strokeStyle = bc.bottom;\n                        ctx.lineWidth = bw.bottom;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n                        ctx.lineTo(0, plotHeight + bw.bottom / 2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.left > 0) {\n                        ctx.strokeStyle = bc.left;\n                        ctx.lineWidth = bw.left;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);\n                        ctx.lineTo(0- bw.left/2, 0);\n                        ctx.stroke();\n                    }\n                }\n                else {\n                    ctx.lineWidth = bw;\n                    ctx.strokeStyle = options.grid.borderColor;\n                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);\n                }\n            }\n\n            ctx.restore();\n        }\n\n        function drawAxisLabels() {\n\n            $.each(allAxes(), function (_, axis) {\n                var box = axis.box,\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\n                    tick, x, y, halign, valign;\n\n                // Remove text before checking for axis.show and ticks.length;\n                // otherwise plugins, like flot-tickrotor, that draw their own\n                // tick labels will end up with both theirs and the defaults.\n\n                surface.removeText(layer);\n\n                if (!axis.show || axis.ticks.length == 0)\n                    return;\n\n                for (var i = 0; i < axis.ticks.length; ++i) {\n\n                    tick = axis.ticks[i];\n                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        halign = \"center\";\n                        x = plotOffset.left + axis.p2c(tick.v);\n                        if (axis.position == \"bottom\") {\n                            y = box.top + box.padding;\n                        } else {\n                            y = box.top + box.height - box.padding;\n                            valign = \"bottom\";\n                        }\n                    } else {\n                        valign = \"middle\";\n                        y = plotOffset.top + axis.p2c(tick.v);\n                        if (axis.position == \"left\") {\n                            x = box.left + box.width - box.padding;\n                            halign = \"right\";\n                        } else {\n                            x = box.left + box.padding;\n                        }\n                    }\n\n                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n                }\n            });\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show)\n                drawSeriesLines(series);\n            if (series.bars.show)\n                drawSeriesBars(series);\n            if (series.points.show)\n                drawSeriesPoints(series);\n        }\n\n        function drawSeriesLines(series) {\n            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    prevx = null, prevy = null;\n\n                ctx.beginPath();\n                for (var i = ps; i < points.length; i += ps) {\n                    var x1 = points[i - ps], y1 = points[i - ps + 1],\n                        x2 = points[i], y2 = points[i + 1];\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min) {\n                        if (y2 < axisy.min)\n                            continue;   // line segment is outside\n                        // compute new intersection point\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min) {\n                        if (y1 < axisy.min)\n                            continue;\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max) {\n                        if (y2 > axisy.max)\n                            continue;\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max) {\n                        if (y1 > axisy.max)\n                            continue;\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (x1 != prevx || y1 != prevy)\n                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n\n                    prevx = x2;\n                    prevy = y2;\n                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n                }\n                ctx.stroke();\n            }\n\n            function plotLineArea(datapoints, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n                    i = 0, top, areaOpen = false,\n                    ypos = 1, segmentStart = 0, segmentEnd = 0;\n\n                // we process each segment in two turns, first forward\n                // direction to sketch out top, then once we hit the\n                // end we go backwards to sketch the bottom\n                while (true) {\n                    if (ps > 0 && i > points.length + ps)\n                        break;\n\n                    i += ps; // ps is negative if going backwards\n\n                    var x1 = points[i - ps],\n                        y1 = points[i - ps + ypos],\n                        x2 = points[i], y2 = points[i + ypos];\n\n                    if (areaOpen) {\n                        if (ps > 0 && x1 != null && x2 == null) {\n                            // at turning point\n                            segmentEnd = i;\n                            ps = -ps;\n                            ypos = 2;\n                            continue;\n                        }\n\n                        if (ps < 0 && i == segmentStart + ps) {\n                            // done with the reverse sweep\n                            ctx.fill();\n                            areaOpen = false;\n                            ps = -ps;\n                            ypos = 1;\n                            i = segmentStart = segmentEnd + ps;\n                            continue;\n                        }\n                    }\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip x values\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (!areaOpen) {\n                        // open area\n                        ctx.beginPath();\n                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                        areaOpen = true;\n                    }\n\n                    // now first check the case where both is outside\n                    if (y1 >= axisy.max && y2 >= axisy.max) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                        continue;\n                    }\n                    else if (y1 <= axisy.min && y2 <= axisy.min) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                        continue;\n                    }\n\n                    // else it's a bit more complicated, there might\n                    // be a flat maxed out rectangle first, then a\n                    // triangular cutout or reverse; to find these\n                    // keep track of the current x values\n                    var x1old = x1, x2old = x2;\n\n                    // clip the y values, without shortcutting, we\n                    // go through all cases in turn\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // if the x value was changed we got a rectangle\n                    // to fill\n                    if (x1 != x1old) {\n                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                        // it goes to (x1, y1), but we fill that below\n                    }\n\n                    // fill triangular section, this sometimes result\n                    // in redundant points if (x1, y1) hasn't changed\n                    // from previous line to, but we just ignore that\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                    // fill the other rectangle if it's there\n                    if (x2 != x2old) {\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                    }\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            var lw = series.lines.lineWidth,\n                sw = series.shadowSize;\n            // FIXME: consider another form of shadow when filling is turned on\n            if (lw > 0 && sw > 0) {\n                // draw shadow as a thick and thin line with transparency\n                ctx.lineWidth = sw;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                // position shadow at angle from the mid of line\n                var angle = Math.PI/18;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);\n                ctx.lineWidth = sw/2;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n            }\n\n            if (lw > 0)\n                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function drawSeriesPoints(series) {\n            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i], y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                        continue;\n\n                    ctx.beginPath();\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n                    if (symbol == \"circle\")\n                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n                    else\n                        symbol(ctx, x, y, radius, shadow);\n                    ctx.closePath();\n\n                    if (fillStyle) {\n                        ctx.fillStyle = fillStyle;\n                        ctx.fill();\n                    }\n                    ctx.stroke();\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var lw = series.points.lineWidth,\n                sw = series.shadowSize,\n                radius = series.points.radius,\n                symbol = series.points.symbol;\n\n            // If the user sets the line width to 0, we change it to a very \n            // small value. A line width of 0 seems to force the default of 1.\n            // Doing the conditional here allows the shadow setting to still be \n            // optional even with a lineWidth of 0.\n\n            if( lw == 0 )\n                lw = 0.0001;\n\n            if (lw > 0 && sw > 0) {\n                // draw shadow in two steps\n                var w = sw / 2;\n                ctx.lineWidth = w;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                plotPoints(series.datapoints, radius, null, w + w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n\n                ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                plotPoints(series.datapoints, radius, null, w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            plotPoints(series.datapoints, radius,\n                       getFillStyle(series.points, series.color), 0, false,\n                       series.xaxis, series.yaxis, symbol);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left, right, bottom, top,\n                drawLeft, drawRight, drawTop, drawBottom,\n                tmp;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            }\n            else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n\n            // clip\n            if (right < axisx.min || left > axisx.max ||\n                top < axisy.min || bottom > axisy.max)\n                return;\n\n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n\n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n\n            // fill the bar\n            if (fillStyleCallback) {\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fillRect(left, top, right - left, bottom - top)\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom);\n                if (drawLeft)\n                    c.lineTo(left, top);\n                else\n                    c.moveTo(left, top);\n                if (drawTop)\n                    c.lineTo(right, top);\n                else\n                    c.moveTo(right, top);\n                if (drawRight)\n                    c.lineTo(right, bottom);\n                else\n                    c.moveTo(right, bottom);\n                if (drawBottom)\n                    c.lineTo(left, bottom);\n                else\n                    c.moveTo(left, bottom);\n                c.stroke();\n            }\n        }\n\n        function drawSeriesBars(series) {\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null)\n                        continue;\n                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // FIXME: figure out a way to add shadows (for instance along the right edge)\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n\n            var barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;\n            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top) {\n            var fill = filloptions.fill;\n            if (!fill)\n                return null;\n\n            if (filloptions.fillColor)\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n\n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill == \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n\n        function insertLegend() {\n\n            if (options.legend.container != null) {\n                $(options.legend.container).html(\"\");\n            } else {\n                placeholder.find(\".legend\").remove();\n            }\n\n            if (!options.legend.show) {\n                return;\n            }\n\n            var fragments = [], entries = [], rowStarted = false,\n                lf = options.legend.labelFormatter, s, label;\n\n            // Build a list of legend entries, with each having a label and a color\n\n            for (var i = 0; i < series.length; ++i) {\n                s = series[i];\n                if (s.label) {\n                    label = lf ? lf(s.label, s) : s.label;\n                    if (label) {\n                        entries.push({\n                            label: label,\n                            color: s.color\n                        });\n                    }\n                }\n            }\n\n            // Sort the legend using either the default or a custom comparator\n\n            if (options.legend.sorted) {\n                if ($.isFunction(options.legend.sorted)) {\n                    entries.sort(options.legend.sorted);\n                } else if (options.legend.sorted == \"reverse\") {\n                \tentries.reverse();\n                } else {\n                    var ascending = options.legend.sorted != \"descending\";\n                    entries.sort(function(a, b) {\n                        return a.label == b.label ? 0 : (\n                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR\n                        );\n                    });\n                }\n            }\n\n            // Generate markup for the list of entries, in their final order\n\n            for (var i = 0; i < entries.length; ++i) {\n\n                var entry = entries[i];\n\n                if (i % options.legend.noColumns == 0) {\n                    if (rowStarted)\n                        fragments.push('</tr>');\n                    fragments.push('<tr>');\n                    rowStarted = true;\n                }\n\n                fragments.push(\n                    '<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' +\n                    '<td class=\"legendLabel\">' + entry.label + '</td>'\n                );\n            }\n\n            if (rowStarted)\n                fragments.push('</tr>');\n\n            if (fragments.length == 0)\n                return;\n\n            var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\n            if (options.legend.container != null)\n                $(options.legend.container).html(table);\n            else {\n                var pos = \"\",\n                    p = options.legend.position,\n                    m = options.legend.margin;\n                if (m[0] == null)\n                    m = [m, m];\n                if (p.charAt(0) == \"n\")\n                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n                else if (p.charAt(0) == \"s\")\n                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n                if (p.charAt(1) == \"e\")\n                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n                else if (p.charAt(1) == \"w\")\n                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n                var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos +';') + '</div>').appendTo(placeholder);\n                if (options.legend.backgroundOpacity != 0.0) {\n                    // put in the transparent background\n                    // separately to avoid blended labels and\n                    // label boxes\n                    var c = options.legend.backgroundColor;\n                    if (c == null) {\n                        c = options.grid.backgroundColor;\n                        if (c && typeof c == \"string\")\n                            c = $.color.parse(c);\n                        else\n                            c = $.color.extract(legend, 'background-color');\n                        c.a = 1;\n                        c = c.toString();\n                    }\n                    var div = legend.children();\n                    $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n                }\n            }\n        }\n\n\n        // interactive features\n\n        var highlights = [],\n            redrawTimeout = null;\n\n        // returns the data item the mouse is over, or null if none is found\n        function findNearbyItem(mouseX, mouseY, seriesFilter) {\n            var maxDistance = options.grid.mouseActiveRadius,\n                smallestDistance = maxDistance * maxDistance + 1,\n                item = null, foundPoint = false, i, j, ps;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(series[i]))\n                    continue;\n\n                var s = series[i],\n                    axisx = s.xaxis,\n                    axisy = s.yaxis,\n                    points = s.datapoints.points,\n                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\n                    my = axisy.c2p(mouseY),\n                    maxx = maxDistance / axisx.scale,\n                    maxy = maxDistance / axisy.scale;\n\n                ps = s.datapoints.pointsize;\n                // with inverse transforms, we can't use the maxx/maxy\n                // optimization, sadly\n                if (axisx.options.inverseTransform)\n                    maxx = Number.MAX_VALUE;\n                if (axisy.options.inverseTransform)\n                    maxy = Number.MAX_VALUE;\n\n                if (s.lines.show || s.points.show) {\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1];\n                        if (x == null)\n                            continue;\n\n                        // For points and lines, the cursor must be within a\n                        // certain distance to the data point\n                        if (x - mx > maxx || x - mx < -maxx ||\n                            y - my > maxy || y - my < -maxy)\n                            continue;\n\n                        // We have to calculate distances in pixels, not in\n                        // data units, because the scales of the axes may be different\n                        var dx = Math.abs(axisx.p2c(x) - mouseX),\n                            dy = Math.abs(axisy.p2c(y) - mouseY),\n                            dist = dx * dx + dy * dy; // we save the sqrt\n\n                        // use <= to ensure last point takes precedence\n                        // (last generally means on top of)\n                        if (dist < smallestDistance) {\n                            smallestDistance = dist;\n                            item = [i, j / ps];\n                        }\n                    }\n                }\n\n                if (s.bars.show && !item) { // no other point can be nearby\n\n                    var barLeft, barRight;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            barLeft = 0;\n                            break;\n                        case \"right\":\n                            barLeft = -s.bars.barWidth;\n                            break;\n                        default:\n                            barLeft = -s.bars.barWidth / 2;\n                    }\n\n                    barRight = barLeft + s.bars.barWidth;\n\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1], b = points[j + 2];\n                        if (x == null)\n                            continue;\n\n                        // for a bar graph, the cursor must be inside the bar\n                        if (series[i].bars.horizontal ?\n                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&\n                             my >= y + barLeft && my <= y + barRight) :\n                            (mx >= x + barLeft && mx <= x + barRight &&\n                             my >= Math.min(b, y) && my <= Math.max(b, y)))\n                                item = [i, j / ps];\n                    }\n                }\n            }\n\n            if (item) {\n                i = item[0];\n                j = item[1];\n                ps = series[i].datapoints.pointsize;\n\n                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n                         dataIndex: j,\n                         series: series[i],\n                         seriesIndex: i };\n            }\n\n            return null;\n        }\n\n        function onMouseMove(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return s[\"hoverable\"] != false; });\n        }\n\n        function onMouseLeave(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return false; });\n        }\n\n        function onClick(e) {\n            triggerClickHoverEvent(\"plotclick\", e,\n                                   function (s) { return s[\"clickable\"] != false; });\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter) {\n            var offset = eventHolder.offset(),\n                canvasX = event.pageX - offset.left - plotOffset.left,\n                canvasY = event.pageY - offset.top - plotOffset.top,\n            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\n\n            pos.pageX = event.pageX;\n            pos.pageY = event.pageY;\n\n            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if (h.auto == eventname &&\n                        !(item && h.series == item.series &&\n                          h.point[0] == item.datapoint[0] &&\n                          h.point[1] == item.datapoint[1]))\n                        unhighlight(h.series, h.point);\n                }\n\n                if (item)\n                    highlight(item.series, item.datapoint, eventname);\n            }\n\n            placeholder.trigger(eventname, [ pos, item ]);\n        }\n\n        function triggerRedrawOverlay() {\n            var t = options.interaction.redrawOverlayInterval;\n            if (t == -1) {      // skip event queue\n                drawOverlay();\n                return;\n            }\n\n            if (!redrawTimeout)\n                redrawTimeout = setTimeout(drawOverlay, t);\n        }\n\n        function drawOverlay() {\n            redrawTimeout = null;\n\n            // draw highlights\n            octx.save();\n            overlay.clear();\n            octx.translate(plotOffset.left, plotOffset.top);\n\n            var i, hi;\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show)\n                    drawBarHighlight(hi.series, hi.point);\n                else\n                    drawPointHighlight(hi.series, hi.point);\n            }\n            octx.restore();\n\n            executeHooks(hooks.drawOverlay, [octx]);\n        }\n\n        function highlight(s, point, auto) {\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i == -1) {\n                highlights.push({ series: s, point: point, auto: auto });\n\n                triggerRedrawOverlay();\n            }\n            else if (!auto)\n                highlights[i].auto = false;\n        }\n\n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                triggerRedrawOverlay();\n                return;\n            }\n\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i != -1) {\n                highlights.splice(i, 1);\n\n                triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series == s && h.point[0] == p[0]\n                    && h.point[1] == p[1])\n                    return i;\n            }\n            return -1;\n        }\n\n        function drawPointHighlight(series, point) {\n            var x = point[0], y = point[1],\n                axisx = series.xaxis, axisy = series.yaxis,\n                highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n\n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                return;\n\n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\n            octx.lineWidth = pointRadius;\n            octx.strokeStyle = highlightColor;\n            var radius = 1.5 * pointRadius;\n            x = axisx.p2c(x);\n            y = axisy.p2c(y);\n\n            octx.beginPath();\n            if (series.points.symbol == \"circle\")\n                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n            else\n                series.points.symbol(octx, x, y, radius, false);\n            octx.closePath();\n            octx.stroke();\n        }\n\n        function drawBarHighlight(series, point) {\n            var highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n                fillStyle = highlightColor,\n                barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            octx.lineWidth = series.bars.lineWidth;\n            octx.strokeStyle = highlightColor;\n\n            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\n                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec == \"string\")\n                return spec;\n            else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c != \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null)\n                            co = co.scale('rgb', c.brightness);\n                        if (c.opacity != null)\n                            co.a *= c.opacity;\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n\n                return gradient;\n            }\n        }\n    }\n\n    // Add the plot function to the top level of the jQuery object\n\n    $.plot = function(placeholder, data, options) {\n        //var t0 = new Date();\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n        return plot;\n    };\n\n    $.plot.version = \"0.8.3\";\n\n    $.plot.plugins = [];\n\n    // Also add the plot function as a chainable property\n\n    $.fn.plot = function(data, options) {\n        return this.each(function() {\n            $.plot(this, data, options);\n        });\n    };\n\n    // round to nearby lower multiple of base\n    function floorInBase(n, base) {\n        return base * Math.floor(n / base);\n    }\n\n})(jQuery);\n\n}.call(window));"],"sourceRoot":""}